/* tslint:disable */
/* eslint-disable */
/**
 * neurostore api
 * Create datasets for meta-analysis
 *
 * The version of the OpenAPI document: 1.0
 * Contact: jamesdkent21@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
    DUMMY_BASE_URL,
    assertParamExists,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    serializeDataIfNeeded,
    toPathString,
    createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Analysis
 */
export interface Analysis {
    /**
     * array of conditions (e.g., 2-back, memory, etc.) that must be the same length as weight.
     * @type {Array<string> | Array<Condition> | Condition & ReadOnly}
     * @memberof Analysis
     */
    condition?: Array<string> | Array<Condition> | (Condition & ReadOnly);
    /**
     *
     * @type {Array<Array<string> | Array<Image>>}
     * @memberof Analysis
     */
    image?: Array<Array<string> | Array<Image>>;
    /**
     *
     * @type {string}
     * @memberof Analysis
     */
    name?: string | null;
    /**
     *
     * @type {Array<Array<string> | Array<Point>>}
     * @memberof Analysis
     */
    point?: Array<Array<string> | Array<Point>>;
    /**
     * weight applied to each condition, must be the same length as condition
     * @type {Array<number>}
     * @memberof Analysis
     */
    weight?: Array<number>;
    /**
     *
     * @type {string}
     * @memberof Analysis
     */
    description?: string | null;
    /**
     *
     * @type {string}
     * @memberof Analysis
     */
    study?: string;
}
/**
 *
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * condition name
     * @type {string}
     * @memberof Condition
     */
    name?: string | null;
    /**
     * condition description
     * @type {string}
     * @memberof Condition
     */
    description?: string | null;
}
/**
 *
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     *
     * @type {string}
     * @memberof Dataset
     */
    name: string | null;
    /**
     *
     * @type {string}
     * @memberof Dataset
     */
    description?: string | null;
    /**
     *
     * @type {string}
     * @memberof Dataset
     */
    publication?: string | null;
    /**
     *
     * @type {string}
     * @memberof Dataset
     */
    doi?: string | null;
    /**
     *
     * @type {string}
     * @memberof Dataset
     */
    pmid?: string | null;
    /**
     *
     * @type {DatasetNimadsData}
     * @memberof Dataset
     */
    nimads_data: DatasetNimadsData;
    /**
     *
     * @type {string}
     * @memberof Dataset
     */
    user?: string | null;
}
/**
 *
 * @export
 * @interface DatasetNimadsData
 */
export interface DatasetNimadsData {
    /**
     *
     * @type {Array<Study>}
     * @memberof DatasetNimadsData
     */
    dataset?: Array<Study>;
}
/**
 * representation of a statistical brain image
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * metadata from image
     * @type {object}
     * @memberof Image
     */
    metadata?: object | null;
    /**
     * URL to image file
     * @type {string}
     * @memberof Image
     */
    url?: string | null;
    /**
     * name of the image file
     * @type {string}
     * @memberof Image
     */
    filename?: string | null;
    /**
     * the template space the image is in
     * @type {string}
     * @memberof Image
     */
    space?: string | null;
    /**
     * The values the image represents
     * @type {string}
     * @memberof Image
     */
    value_type?: string | null;
    /**
     * name of the analysis
     * @type {string}
     * @memberof Image
     */
    analysis_name?: string | null;
    /**
     * ID of the analysis this image came from
     * @type {string}
     * @memberof Image
     */
    analysis?: string;
    /**
     * date the image was added
     * @type {string}
     * @memberof Image
     */
    add_date?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {Array<Study & ReadOnly>}
     * @memberof InlineResponse200
     */
    results?: Array<Study & ReadOnly>;
    /**
     *
     * @type {Metadata}
     * @memberof InlineResponse200
     */
    metadata?: Metadata;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     *
     * @type {Metadata}
     * @memberof InlineResponse2001
     */
    metadata?: Metadata;
    /**
     *
     * @type {Array<Analysis & ReadOnly>}
     * @memberof InlineResponse2001
     */
    results?: Array<Analysis & ReadOnly>;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     *
     * @type {Metadata}
     * @memberof InlineResponse2002
     */
    metadata?: Metadata;
    /**
     *
     * @type {Array<Image & ReadOnly>}
     * @memberof InlineResponse2002
     */
    results?: Array<Image & ReadOnly>;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     *
     * @type {Metadata}
     * @memberof InlineResponse2003
     */
    metadata?: Metadata;
    /**
     *
     * @type {Array<Condition & ReadOnly>}
     * @memberof InlineResponse2003
     */
    results?: Array<Condition & ReadOnly>;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     *
     * @type {Metadata}
     * @memberof InlineResponse2004
     */
    metadata?: Metadata;
    /**
     *
     * @type {Array<User>}
     * @memberof InlineResponse2004
     */
    results?: Array<User>;
}
/**
 *
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse404
     */
    detail?: string;
    /**
     *
     * @type {number}
     * @memberof InlineResponse404
     */
    status?: InlineResponse404StatusEnum;
    /**
     *
     * @type {string}
     * @memberof InlineResponse404
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse404
     */
    type?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum InlineResponse404StatusEnum {
    NUMBER_404 = 404,
}

/**
 *
 * @export
 * @interface InlineResponse422
 */
export interface InlineResponse422 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse422
     */
    detail?: string;
    /**
     *
     * @type {number}
     * @memberof InlineResponse422
     */
    status?: number;
    /**
     *
     * @type {string}
     * @memberof InlineResponse422
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse422
     */
    type?: string;
}
/**
 * JSON-LD elements for data tracking
 * @export
 * @interface JsonLd
 */
export interface JsonLd {
    /**
     *
     * @type {JsonLdContext}
     * @memberof JsonLd
     */
    context?: JsonLdContext;
    /**
     * URI of the resource
     * @type {string}
     * @memberof JsonLd
     */
    id?: string;
    /**
     * One of the NiMADS data types
     * @type {string}
     * @memberof JsonLd
     */
    type?: string;
}
/**
 * Context for the shorthand names
 * @export
 * @interface JsonLdContext
 */
export interface JsonLdContext {
    /**
     * common URI prefix for @type
     * @type {string}
     * @memberof JsonLdContext
     */
    vocab?: string;
}
/**
 * data included in every list response
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * total number of entries
     * @type {number}
     * @memberof Metadata
     */
    total_count?: number;
    /**
     * count of elements for unique entries
     * @type {number}
     * @memberof Metadata
     */
    unique_count?: number;
}
/**
 * a coordinate in the brain
 * @export
 * @interface Point
 */
export interface Point {
    /**
     * location of the point
     * @type {Array<number>}
     * @memberof Point
     */
    coordinates?: Array<number>;
    /**
     * template space used to determine coordinate (TAL or MNI or UNKNOWN)
     * @type {string}
     * @memberof Point
     */
    space?: string;
    /**
     * method of how point was derived (e.g., center of mass)
     * @type {string}
     * @memberof Point
     */
    kind?: string | null;
    /**
     *
     * @type {number}
     * @memberof Point
     */
    x?: number;
    /**
     *
     * @type {number}
     * @memberof Point
     */
    y?: number;
    /**
     *
     * @type {number}
     * @memberof Point
     */
    z?: number;
    /**
     *
     * @type {string}
     * @memberof Point
     */
    analysis?: string;
}
/**
 *
 * @export
 * @interface PointValue
 */
export interface PointValue {
    /**
     *
     * @type {string}
     * @memberof PointValue
     */
    kind?: string | null;
    /**
     *
     * @type {number}
     * @memberof PointValue
     */
    value?: number | null;
}
/**
 * common read-only attributes
 * @export
 * @interface ReadOnly
 */
export interface ReadOnly {
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof ReadOnly
     */
    id?: string;
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof ReadOnly
     */
    created_at?: string;
}
/**
 * attributes of a study/published paper
 * @export
 * @interface Study
 */
export interface Study {
    /**
     *
     * @type {Array<Array<string> | Array<Analysis> | Array<Analysis & ReadOnly>>}
     * @memberof Study
     */
    analysis?: Array<Array<string> | Array<Analysis> | Array<Analysis & ReadOnly>>;
    /**
     * digital object identifier of the study
     * @type {string}
     * @memberof Study
     */
    doi?: string | null;
    /**
     * title of the study
     * @type {string}
     * @memberof Study
     */
    name?: string | null;
    /**
     * other metadata associated with the study
     * @type {object}
     * @memberof Study
     */
    metadata?: object | null;
    /**
     *
     * @type {string}
     * @memberof Study
     */
    description?: string | null;
    /**
     *
     * @type {string}
     * @memberof Study
     */
    publication?: string | null;
    /**
     *
     * @type {string}
     * @memberof Study
     */
    pmid?: string | null;
    /**
     * whether the study is visible to everyone or just you
     * @type {boolean}
     * @memberof Study
     */
    _public?: boolean;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     * full name of user
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    neuroid?: string;
}

/**
 * AnalysesApi - axios parameter creator
 * @export
 */
export const AnalysesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesGet: async (
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            name?: string,
            description?: string,
            options: any = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdGet: async (id: string, nested?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdGet', 'id', id);
            const localVarPath = `/analyses/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id
         * @param {Analysis} [analysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdPut: async (id: string, analysis?: Analysis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdPut', 'id', id);
            const localVarPath = `/analyses/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(analysis, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {Analysis} [analysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesPost: async (analysis?: Analysis, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(analysis, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AnalysesApi - functional programming interface
 * @export
 */
export const AnalysesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalysesApiAxiosParamCreator(configuration);
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesGet(
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            name?: string,
            description?: string,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesGet(
                search,
                sort,
                page,
                desc,
                pageSize,
                name,
                description,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdGet(
            id: string,
            nested?: boolean,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Analysis & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdGet(id, nested, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id
         * @param {Analysis} [analysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdPut(
            id: string,
            analysis?: Analysis,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdPut(id, analysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {Analysis} [analysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesPost(
            analysis?: Analysis,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesPost(analysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * AnalysesApi - factory interface
 * @export
 */
export const AnalysesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalysesApiFp(configuration);
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesGet(
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            name?: string,
            description?: string,
            options?: any,
        ): AxiosPromise<InlineResponse2001> {
            return localVarFp
                .analysesGet(search, sort, page, desc, pageSize, name, description, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdGet(id: string, nested?: boolean, options?: any): AxiosPromise<Analysis & ReadOnly> {
            return localVarFp.analysesIdGet(id, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id
         * @param {Analysis} [analysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdPut(id: string, analysis?: Analysis, options?: any): AxiosPromise<void> {
            return localVarFp.analysesIdPut(id, analysis, options).then((request) => request(axios, basePath));
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {Analysis} [analysis]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesPost(analysis?: Analysis, options?: any): AxiosPromise<void> {
            return localVarFp.analysesPost(analysis, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalysesApi - object-oriented interface
 * @export
 * @class AnalysesApi
 * @extends {BaseAPI}
 */
export class AnalysesApi extends BaseAPI {
    /**
     * List all analyses performed across studies.
     * @summary GET list of analyses
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesGet(
        search?: string,
        sort?: string,
        page?: number,
        desc?: boolean,
        pageSize?: number,
        name?: string,
        description?: string,
        options?: any,
    ) {
        return AnalysesApiFp(this.configuration)
            .analysesGet(search, sort, page, desc, pageSize, name, description, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information pertaining to a particular analysis within a study.
     * @summary GET an analysis
     * @param {string} id
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesIdGet(id: string, nested?: boolean, options?: any) {
        return AnalysesApiFp(this.configuration)
            .analysesIdGet(id, nested, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing analysis.
     * @summary PUT/update an analysis
     * @param {string} id
     * @param {Analysis} [analysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesIdPut(id: string, analysis?: Analysis, options?: any) {
        return AnalysesApiFp(this.configuration)
            .analysesIdPut(id, analysis, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * create an analysis
     * @summary POST/create an analysis
     * @param {Analysis} [analysis]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesPost(analysis?: Analysis, options?: any) {
        return AnalysesApiFp(this.configuration)
            .analysesPost(analysis, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ConditionsApi - axios parameter creator
 * @export
 */
export const ConditionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsGet: async (
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            name?: string,
            description?: string,
            options: any = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/conditions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdGet', 'id', id);
            const localVarPath = `/conditions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id
         * @param {Condition} [condition]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdPut: async (id: string, condition?: Condition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdPut', 'id', id);
            const localVarPath = `/conditions/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(condition, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {Condition} [condition]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsPost: async (condition?: Condition, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/conditions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(condition, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ConditionsApi - functional programming interface
 * @export
 */
export const ConditionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ConditionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsGet(
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            name?: string,
            description?: string,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsGet(
                search,
                sort,
                page,
                desc,
                pageSize,
                name,
                description,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdGet(
            id: string,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Condition & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id
         * @param {Condition} [condition]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdPut(
            id: string,
            condition?: Condition,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdPut(id, condition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {Condition} [condition]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsPost(
            condition?: Condition,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Condition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsPost(condition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ConditionsApi - factory interface
 * @export
 */
export const ConditionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConditionsApiFp(configuration);
    return {
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsGet(
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            name?: string,
            description?: string,
            options?: any,
        ): AxiosPromise<InlineResponse2003> {
            return localVarFp
                .conditionsGet(search, sort, page, desc, pageSize, name, description, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdGet(id: string, options?: any): AxiosPromise<Condition & ReadOnly> {
            return localVarFp.conditionsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id
         * @param {Condition} [condition]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdPut(id: string, condition?: Condition, options?: any): AxiosPromise<void> {
            return localVarFp.conditionsIdPut(id, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {Condition} [condition]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsPost(condition?: Condition, options?: any): AxiosPromise<Condition> {
            return localVarFp.conditionsPost(condition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConditionsApi - object-oriented interface
 * @export
 * @class ConditionsApi
 * @extends {BaseAPI}
 */
export class ConditionsApi extends BaseAPI {
    /**
     * Get all conditions
     * @summary GET Conditions
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsGet(
        search?: string,
        sort?: string,
        page?: number,
        desc?: boolean,
        pageSize?: number,
        name?: string,
        description?: string,
        options?: any,
    ) {
        return ConditionsApiFp(this.configuration)
            .conditionsGet(search, sort, page, desc, pageSize, name, description, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
     * @summary GET a condition
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsIdGet(id: string, options?: any) {
        return ConditionsApiFp(this.configuration)
            .conditionsIdGet(id, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a condition
     * @summary PUT/update a condition
     * @param {string} id
     * @param {Condition} [condition]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsIdPut(id: string, condition?: Condition, options?: any) {
        return ConditionsApiFp(this.configuration)
            .conditionsIdPut(id, condition, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a condition
     * @summary POST/Create a condition
     * @param {Condition} [condition]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsPost(condition?: Condition, options?: any) {
        return ConditionsApiFp(this.configuration)
            .conditionsPost(condition, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DatasetsApi - axios parameter creator
 * @export
 */
export const DatasetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of datasets.
         * @summary GET a list of datasets
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsGet: async (
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            options: any = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/datasets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the information of a dataset with the matching dataset ID.
         * @summary GET a dataset
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasetsIdGet', 'id', id);
            const localVarPath = `/datasets/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a dataset.
         * @summary PUT/update a dataset
         * @param {string} id
         * @param {Dataset} [dataset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsIdPut: async (id: string, dataset?: Dataset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasetsIdPut', 'id', id);
            const localVarPath = `/datasets/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a dataset.
         * @summary POST/create a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/datasets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DatasetsApi - functional programming interface
 * @export
 */
export const DatasetsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a list of datasets.
         * @summary GET a list of datasets
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsGet(
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset & ReadOnly>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsGet(
                search,
                sort,
                page,
                desc,
                pageSize,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the information of a dataset with the matching dataset ID.
         * @summary GET a dataset
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsIdGet(
            id: string,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a dataset.
         * @summary PUT/update a dataset
         * @param {string} id
         * @param {Dataset} [dataset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsIdPut(
            id: string,
            dataset?: Dataset,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsIdPut(id, dataset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a dataset.
         * @summary POST/create a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsPost(
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DatasetsApi - factory interface
 * @export
 */
export const DatasetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetsApiFp(configuration);
    return {
        /**
         * Get a list of datasets.
         * @summary GET a list of datasets
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsGet(
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            options?: any,
        ): AxiosPromise<Array<Dataset & ReadOnly>> {
            return localVarFp
                .datasetsGet(search, sort, page, desc, pageSize, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the information of a dataset with the matching dataset ID.
         * @summary GET a dataset
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsIdGet(id: string, options?: any): AxiosPromise<Dataset & ReadOnly> {
            return localVarFp.datasetsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a dataset.
         * @summary PUT/update a dataset
         * @param {string} id
         * @param {Dataset} [dataset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsIdPut(id: string, dataset?: Dataset, options?: any): AxiosPromise<void> {
            return localVarFp.datasetsIdPut(id, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a dataset.
         * @summary POST/create a dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsPost(options?: any): AxiosPromise<Dataset> {
            return localVarFp.datasetsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetsApi - object-oriented interface
 * @export
 * @class DatasetsApi
 * @extends {BaseAPI}
 */
export class DatasetsApi extends BaseAPI {
    /**
     * Get a list of datasets.
     * @summary GET a list of datasets
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsGet(
        search?: string,
        sort?: string,
        page?: number,
        desc?: boolean,
        pageSize?: number,
        options?: any,
    ) {
        return DatasetsApiFp(this.configuration)
            .datasetsGet(search, sort, page, desc, pageSize, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the information of a dataset with the matching dataset ID.
     * @summary GET a dataset
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsIdGet(id: string, options?: any) {
        return DatasetsApiFp(this.configuration)
            .datasetsIdGet(id, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a dataset.
     * @summary PUT/update a dataset
     * @param {string} id
     * @param {Dataset} [dataset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsIdPut(id: string, dataset?: Dataset, options?: any) {
        return DatasetsApiFp(this.configuration)
            .datasetsIdPut(id, dataset, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a dataset.
     * @summary POST/create a dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsPost(options?: any) {
        return DatasetsApiFp(this.configuration)
            .datasetsPost(options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesGet: async (
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            filename?: string,
            analysisName?: string,
            valueType?: string,
            space?: string,
            options: any = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/images/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (analysisName !== undefined) {
                localVarQueryParameter['analysis_name'] = analysisName;
            }

            if (valueType !== undefined) {
                localVarQueryParameter['value_type'] = valueType;
            }

            if (space !== undefined) {
                localVarQueryParameter['space'] = space;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdGet', 'id', id);
            const localVarPath = `/images/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id
         * @param {Image} [image]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdPut: async (id: string, image?: Image, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdPut', 'id', id);
            const localVarPath = `/images/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(image, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {Image} [image]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesPost: async (image?: Image, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/images/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(image, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesGet(
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            filename?: string,
            analysisName?: string,
            valueType?: string,
            space?: string,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesGet(
                search,
                sort,
                page,
                desc,
                pageSize,
                filename,
                analysisName,
                valueType,
                space,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdGet(
            id: string,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id
         * @param {Image} [image]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdPut(
            id: string,
            image?: Image,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdPut(id, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {Image} [image]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesPost(
            image?: Image,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesPost(image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration);
    return {
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesGet(
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            filename?: string,
            analysisName?: string,
            valueType?: string,
            space?: string,
            options?: any,
        ): AxiosPromise<InlineResponse2002> {
            return localVarFp
                .imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdGet(id: string, options?: any): AxiosPromise<Image & ReadOnly> {
            return localVarFp.imagesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id
         * @param {Image} [image]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdPut(id: string, image?: Image, options?: any): AxiosPromise<void> {
            return localVarFp.imagesIdPut(id, image, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {Image} [image]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesPost(image?: Image, options?: any): AxiosPromise<Image> {
            return localVarFp.imagesPost(image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * Retrieve and list images.
     * @summary GET a list of images
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [filename] search filename field
     * @param {string} [analysisName] search analysis_name field
     * @param {string} [valueType] search value_type field
     * @param {string} [space] search space field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesGet(
        search?: string,
        sort?: string,
        page?: number,
        desc?: boolean,
        pageSize?: number,
        filename?: string,
        analysisName?: string,
        valueType?: string,
        space?: string,
        options?: any,
    ) {
        return ImagesApiFp(this.configuration)
            .imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about a particular image from an analysis.
     * @summary GET an image
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesIdGet(id: string, options?: any) {
        return ImagesApiFp(this.configuration)
            .imagesIdGet(id, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific image.
     * @summary PUT/update an image
     * @param {string} id
     * @param {Image} [image]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesIdPut(id: string, image?: Image, options?: any) {
        return ImagesApiFp(this.configuration)
            .imagesIdPut(id, image, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an image
     * @summary POST/create an image
     * @param {Image} [image]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesPost(image?: Image, options?: any) {
        return ImagesApiFp(this.configuration)
            .imagesPost(image, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * PointsApi - axios parameter creator
 * @export
 */
export const PointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdGet', 'id', id);
            const localVarPath = `/points/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id
         * @param {Point} [point]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdPut: async (id: string, point?: Point, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdPut', 'id', id);
            const localVarPath = `/points/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(point, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * PointsApi - functional programming interface
 * @export
 */
export const PointsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PointsApiAxiosParamCreator(configuration);
    return {
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdGet(
            id: string,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Point & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id
         * @param {Point} [point]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdPut(
            id: string,
            point?: Point,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdPut(id, point, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * PointsApi - factory interface
 * @export
 */
export const PointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PointsApiFp(configuration);
    return {
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdGet(id: string, options?: any): AxiosPromise<Point & ReadOnly> {
            return localVarFp.pointsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id
         * @param {Point} [point]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdPut(id: string, point?: Point, options?: any): AxiosPromise<void> {
            return localVarFp.pointsIdPut(id, point, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PointsApi - object-oriented interface
 * @export
 * @class PointsApi
 * @extends {BaseAPI}
 */
export class PointsApi extends BaseAPI {
    /**
     * Information about a particular MRI coordinate
     * @summary GET a point
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsIdGet(id: string, options?: any) {
        return PointsApiFp(this.configuration)
            .pointsIdGet(id, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a particular MRI coordinate.
     * @summary PUT/update a point
     * @param {string} id
     * @param {Point} [point]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsIdPut(id: string, point?: Point, options?: any) {
        return PointsApiFp(this.configuration)
            .pointsIdPut(id, point, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * StudiesApi - axios parameter creator
 * @export
 */
export const StudiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the study you would like to copy from
         * @param {boolean} [unique] whether to list clones with originals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesGet: async (
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            nested?: boolean,
            name?: string,
            description?: string,
            sourceId?: string,
            unique?: boolean,
            options: any = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            if (unique !== undefined) {
                localVarQueryParameter['unique'] = unique;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdGet: async (id: string, nested?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdGet', 'id', id);
            const localVarPath = `/studies/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id
         * @param {Study} [study]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdPut: async (id: string, study?: Study, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdPut', 'id', id);
            const localVarPath = `/studies/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(study, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {'neurostore' | 'neurovault' | 'pubmed'} [source] the source of the study you would like to copy from, use in conjunction with source_id
         * @param {string} [sourceId] id of the study you would like to copy from
         * @param {Study} [study]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesPost: async (
            source?: 'neurostore' | 'neurovault' | 'pubmed',
            sourceId?: string,
            study?: Study,
            options: any = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(study, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * StudiesApi - functional programming interface
 * @export
 */
export const StudiesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = StudiesApiAxiosParamCreator(configuration);
    return {
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the study you would like to copy from
         * @param {boolean} [unique] whether to list clones with originals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesGet(
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            nested?: boolean,
            name?: string,
            description?: string,
            sourceId?: string,
            unique?: boolean,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesGet(
                search,
                sort,
                page,
                desc,
                pageSize,
                nested,
                name,
                description,
                sourceId,
                unique,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdGet(
            id: string,
            nested?: boolean,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Study & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdGet(id, nested, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id
         * @param {Study} [study]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdPut(
            id: string,
            study?: Study,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdPut(id, study, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {'neurostore' | 'neurovault' | 'pubmed'} [source] the source of the study you would like to copy from, use in conjunction with source_id
         * @param {string} [sourceId] id of the study you would like to copy from
         * @param {Study} [study]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesPost(
            source?: 'neurostore' | 'neurovault' | 'pubmed',
            sourceId?: string,
            study?: Study,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesPost(source, sourceId, study, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * StudiesApi - factory interface
 * @export
 */
export const StudiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudiesApiFp(configuration);
    return {
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the study you would like to copy from
         * @param {boolean} [unique] whether to list clones with originals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesGet(
            search?: string,
            sort?: string,
            page?: number,
            desc?: boolean,
            pageSize?: number,
            nested?: boolean,
            name?: string,
            description?: string,
            sourceId?: string,
            unique?: boolean,
            options?: any,
        ): AxiosPromise<InlineResponse200> {
            return localVarFp
                .studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdGet(id: string, nested?: boolean, options?: any): AxiosPromise<Study & ReadOnly> {
            return localVarFp.studiesIdGet(id, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id
         * @param {Study} [study]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdPut(id: string, study?: Study & ReadOnly, options?: any): AxiosPromise<void> {
            return localVarFp.studiesIdPut(id, study, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {'neurostore' | 'neurovault' | 'pubmed'} [source] the source of the study you would like to copy from, use in conjunction with source_id
         * @param {string} [sourceId] id of the study you would like to copy from
         * @param {Study} [study]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesPost(
            source?: 'neurostore' | 'neurovault' | 'pubmed',
            sourceId?: string,
            study?: Study,
            options?: any,
        ): AxiosPromise<void> {
            return localVarFp.studiesPost(source, sourceId, study, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudiesApi - object-oriented interface
 * @export
 * @class StudiesApi
 * @extends {BaseAPI}
 */
export class StudiesApi extends BaseAPI {
    /**
     * List studies
     * @summary GET a list of studies
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {string} [sourceId] id of the study you would like to copy from
     * @param {boolean} [unique] whether to list clones with originals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesGet(
        search?: string,
        sort?: string,
        page?: number,
        desc?: boolean,
        pageSize?: number,
        nested?: boolean,
        name?: string,
        description?: string,
        sourceId?: string,
        unique?: boolean,
        options?: any,
    ) {
        return StudiesApiFp(this.configuration)
            .studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a study.
     * @summary GET a study
     * @param {string} id
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesIdGet(id: string, nested?: boolean, options?: any) {
        return StudiesApiFp(this.configuration)
            .studiesIdGet(id, nested, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a study.
     * @summary PUT/update a study
     * @param {string} id
     * @param {Study} [study]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesIdPut(id: string, study?: Study, options?: any) {
        return StudiesApiFp(this.configuration)
            .studiesIdPut(id, study, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a study
     * @summary POST/create a study
     * @param {'neurostore' | 'neurovault' | 'pubmed'} [source] the source of the study you would like to copy from, use in conjunction with source_id
     * @param {string} [sourceId] id of the study you would like to copy from
     * @param {Study} [study]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesPost(
        source?: 'neurostore' | 'neurovault' | 'pubmed',
        sourceId?: string,
        study?: Study,
        options?: any,
    ) {
        return StudiesApiFp(this.configuration)
            .studiesPost(source, sourceId, study, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get list of users
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a user
         * @param {User} [user]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (user?: User, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration);

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
    return {
        /**
         * get list of users
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create a user
         * @param {User} [user]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(
            user?: User,
            options?: any,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration);
    return {
        /**
         * get list of users
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.usersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * create a user
         * @param {User} [user]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user?: User, options?: any): AxiosPromise<User> {
            return localVarFp.usersPost(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * get list of users
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersGet(options?: any) {
        return UserApiFp(this.configuration)
            .usersGet(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a user
     * @param {User} [user]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersPost(user?: User, options?: any) {
        return UserApiFp(this.configuration)
            .usersPost(user, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
