/* tslint:disable */
/* eslint-disable */
/**
 * neurostore api
 * Create datasets for meta-analysis
 *
 * The version of the OpenAPI document: 1.0
 * Contact: jamesdkent21@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Analysis
 */
export interface Analysis {
    /**
     * array of conditions (e.g., 2-back, memory, etc.) that must be the same length as weight.
     * @type {Array<string | Condition & ReadOnly>}
     * @memberof Analysis
     */
    conditions?: Array<string | Condition & ReadOnly>;
    /**
     * 
     * @type {Array<string | Image & ReadOnly>}
     * @memberof Analysis
     */
    images?: Array<string | Image & ReadOnly>;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    name?: string | null;
    /**
     * 
     * @type {Array<string | Point & ReadOnly>}
     * @memberof Analysis
     */
    points?: Array<string | Point & ReadOnly>;
    /**
     * weight applied to each condition, must be the same length as condition
     * @type {Array<number>}
     * @memberof Analysis
     */
    weights?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Analysis
     */
    study?: string;
}
/**
 * 
 * @export
 * @interface Annotation
 */
export interface Annotation {
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    dataset?: string;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    description?: string | null;
    /**
     * 
     * @type {Array<AnnotationNote & ReadOnly>}
     * @memberof Annotation
     */
    notes?: Array<AnnotationNote & ReadOnly>;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    source?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    source_id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    source_updated_at?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Annotation
     */
    metadata?: object | null;
    /**
     * 
     * @type {boolean}
     * @memberof Annotation
     */
    _public?: boolean;
    /**
     * 
     * @type {object}
     * @memberof Annotation
     */
    note_keys?: object;
}
/**
 * 
 * @export
 * @interface AnnotationExport
 */
export interface AnnotationExport {
    /**
     * 
     * @type {object}
     * @memberof AnnotationExport
     */
    metadata?: object | null;
    /**
     * 
     * @type {string}
     * @memberof AnnotationExport
     */
    annotation_csv?: string;
}
/**
 * 
 * @export
 * @interface AnnotationNote
 */
export interface AnnotationNote {
    /**
     * 
     * @type {string}
     * @memberof AnnotationNote
     */
    analysis?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationNote
     */
    study?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationNote
     */
    study_name?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationNote
     */
    annotation?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationNote
     */
    analysis_name?: string | null;
    /**
     * 
     * @type {object}
     * @memberof AnnotationNote
     */
    note?: object;
    /**
     * 
     * @type {number}
     * @memberof AnnotationNote
     */
    study_year?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AnnotationNote
     */
    publication?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AnnotationNote
     */
    authors?: string | null;
}
/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * condition name
     * @type {string}
     * @memberof Condition
     */
    name?: string | null;
    /**
     * condition description
     * @type {string}
     * @memberof Condition
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    publication?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    doi?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    pmid?: string | null;
    /**
     * 
     * @type {Array<Study & ReadOnly | string>}
     * @memberof Dataset
     */
    studies?: Array<Study & ReadOnly | string>;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    user?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Dataset
     */
    _public?: boolean;
}
/**
 * representation of a statistical brain image
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * metadata from image
     * @type {object}
     * @memberof Image
     */
    metadata?: object | null;
    /**
     * URL to image file
     * @type {string}
     * @memberof Image
     */
    url?: string | null;
    /**
     * name of the image file
     * @type {string}
     * @memberof Image
     */
    filename?: string | null;
    /**
     * the template space the image is in
     * @type {string}
     * @memberof Image
     */
    space?: string | null;
    /**
     * The values the image represents
     * @type {string}
     * @memberof Image
     */
    value_type?: string | null;
    /**
     * name of the analysis
     * @type {string}
     * @memberof Image
     */
    analysis_name?: string | null;
    /**
     * ID of the analysis this image came from
     * @type {string}
     * @memberof Image
     */
    analysis?: string;
    /**
     * date the image was added
     * @type {string}
     * @memberof Image
     */
    add_date?: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<Dataset & ReadOnly>}
     * @memberof InlineResponse200
     */
    results?: Array<Dataset & ReadOnly>;
    /**
     * 
     * @type {Metadata}
     * @memberof InlineResponse200
     */
    metadata?: Metadata;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<Study & ReadOnly>}
     * @memberof InlineResponse2001
     */
    results?: Array<Study & ReadOnly>;
    /**
     * 
     * @type {Metadata}
     * @memberof InlineResponse2001
     */
    metadata?: Metadata;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineResponse2002
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<Analysis & ReadOnly>}
     * @memberof InlineResponse2002
     */
    results?: Array<Analysis & ReadOnly>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<Point & ReadOnly>}
     * @memberof InlineResponse2003
     */
    results?: Array<Point & ReadOnly>;
    /**
     * 
     * @type {Metadata}
     * @memberof InlineResponse2003
     */
    metadata?: Metadata;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineResponse2004
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<Image & ReadOnly>}
     * @memberof InlineResponse2004
     */
    results?: Array<Image & ReadOnly>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineResponse2005
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<Condition & ReadOnly>}
     * @memberof InlineResponse2005
     */
    results?: Array<Condition & ReadOnly>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineResponse2006
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<Annotation & ReadOnly>}
     * @memberof InlineResponse2006
     */
    results?: Array<Annotation & ReadOnly>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {Metadata}
     * @memberof InlineResponse2007
     */
    metadata?: Metadata;
    /**
     * 
     * @type {Array<User>}
     * @memberof InlineResponse2007
     */
    results?: Array<User>;
}
/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    detail?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse404
     */
    status?: InlineResponse404StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    type?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse404StatusEnum {
    NUMBER_404 = 404
}

/**
 * 
 * @export
 * @interface InlineResponse422
 */
export interface InlineResponse422 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse422
     */
    detail?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse422
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse422
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse422
     */
    type?: string;
}
/**
 * JSON-LD elements for data tracking
 * @export
 * @interface JsonLd
 */
export interface JsonLd {
    /**
     * 
     * @type {JsonLdContext}
     * @memberof JsonLd
     */
    context?: JsonLdContext;
    /**
     * URI of the resource
     * @type {string}
     * @memberof JsonLd
     */
    id?: string;
    /**
     * One of the NiMADS data types
     * @type {string}
     * @memberof JsonLd
     */
    type?: string;
}
/**
 * Context for the shorthand names
 * @export
 * @interface JsonLdContext
 */
export interface JsonLdContext {
    /**
     * common URI prefix for @type
     * @type {string}
     * @memberof JsonLdContext
     */
    vocab?: string;
}
/**
 * data included in every list response
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * total number of entries 
     * @type {number}
     * @memberof Metadata
     */
    total_count?: number;
    /**
     * count of elements for unique entries
     * @type {number}
     * @memberof Metadata
     */
    unique_count?: number;
}
/**
 * a coordinate in the brain
 * @export
 * @interface Point
 */
export interface Point {
    /**
     * location of the point
     * @type {Array<number>}
     * @memberof Point
     */
    coordinates?: Array<number>;
    /**
     * template space used to determine coordinate (TAL or MNI or UNKNOWN)
     * @type {string}
     * @memberof Point
     */
    space?: string | null;
    /**
     * method of how point was derived (e.g., center of mass)
     * @type {string}
     * @memberof Point
     */
    kind?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Point
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof Point
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof Point
     */
    z?: number;
    /**
     * 
     * @type {string}
     * @memberof Point
     */
    analysis?: string;
    /**
     * 
     * @type {string}
     * @memberof Point
     */
    image?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Point
     */
    label_id?: string | null;
    /**
     * 
     * @type {Array<string | PointValue & ReadOnly>}
     * @memberof Point
     */
    value?: Array<string | PointValue & ReadOnly>;
}
/**
 * 
 * @export
 * @interface PointValue
 */
export interface PointValue {
    /**
     * 
     * @type {string}
     * @memberof PointValue
     */
    kind?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PointValue
     */
    value?: number | null;
}
/**
 * common read-only attributes
 * @export
 * @interface ReadOnly
 */
export interface ReadOnly {
    /**
     * short UUID specifying the location of this resource
     * @type {string}
     * @memberof ReadOnly
     */
    id?: string;
    /**
     * time the resource was created on the database
     * @type {string}
     * @memberof ReadOnly
     */
    created_at?: string;
    /**
     * who owns the resource
     * @type {string}
     * @memberof ReadOnly
     */
    user?: string | null;
}
/**
 * attributes of a study/published paper
 * @export
 * @interface Study
 */
export interface Study {
    /**
     * 
     * @type {Array<string | ReadOnly & Analysis>}
     * @memberof Study
     */
    analyses?: Array<string | ReadOnly & Analysis>;
    /**
     * digital object identifier of the study
     * @type {string}
     * @memberof Study
     */
    doi?: string | null;
    /**
     * title of the study
     * @type {string}
     * @memberof Study
     */
    name?: string | null;
    /**
     * other metadata associated with the study
     * @type {object}
     * @memberof Study
     */
    metadata?: object | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    publication?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    pmid?: string | null;
    /**
     * whether the study is visible to everyone or just you
     * @type {boolean}
     * @memberof Study
     */
    _public?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    authors?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    source?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    source_id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Study
     */
    source_updated_at?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Study
     */
    year?: number | null;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * full name of user
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    neuroid?: string;
}

/**
 * AnalysesApi - axios parameter creator
 * @export
 */
export const AnalysesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete an analysis
         * @summary DELETE an analysis
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdDelete', 'id', id)
            const localVarPath = `/analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdGet: async (id: string, nested?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdGet', 'id', id)
            const localVarPath = `/analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id 
         * @param {Analysis} [analysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdPut: async (id: string, analysis?: Analysis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('analysesIdPut', 'id', id)
            const localVarPath = `/analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysis, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {Analysis} [analysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesPost: async (analysis?: Analysis, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/analyses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysis, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalysesApi - functional programming interface
 * @export
 */
export const AnalysesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalysesApiAxiosParamCreator(configuration)
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesGet(search, sort, page, desc, pageSize, name, description, nested, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete an analysis
         * @summary DELETE an analysis
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdGet(id: string, nested?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Analysis & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdGet(id, nested, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id 
         * @param {Analysis} [analysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesIdPut(id: string, analysis?: Analysis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesIdPut(id, analysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {Analysis} [analysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analysesPost(analysis?: Analysis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analysesPost(analysis, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnalysesApi - factory interface
 * @export
 */
export const AnalysesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalysesApiFp(configuration)
    return {
        /**
         * List all analyses performed across studies.
         * @summary GET list of analyses
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.analysesGet(search, sort, page, desc, pageSize, name, description, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * delete an analysis
         * @summary DELETE an analysis
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.analysesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Information pertaining to a particular analysis within a study.
         * @summary GET an analysis
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdGet(id: string, nested?: boolean, options?: any): AxiosPromise<Analysis & ReadOnly> {
            return localVarFp.analysesIdGet(id, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing analysis.
         * @summary PUT/update an analysis
         * @param {string} id 
         * @param {Analysis} [analysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesIdPut(id: string, analysis?: Analysis, options?: any): AxiosPromise<void> {
            return localVarFp.analysesIdPut(id, analysis, options).then((request) => request(axios, basePath));
        },
        /**
         * create an analysis
         * @summary POST/create an analysis
         * @param {Analysis} [analysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analysesPost(analysis?: Analysis, options?: any): AxiosPromise<void> {
            return localVarFp.analysesPost(analysis, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalysesApi - object-oriented interface
 * @export
 * @class AnalysesApi
 * @extends {BaseAPI}
 */
export class AnalysesApi extends BaseAPI {
    /**
     * List all analyses performed across studies.
     * @summary GET list of analyses
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, nested?: boolean, options?: any) {
        return AnalysesApiFp(this.configuration).analysesGet(search, sort, page, desc, pageSize, name, description, nested, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete an analysis
     * @summary DELETE an analysis
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesIdDelete(id: string, options?: any) {
        return AnalysesApiFp(this.configuration).analysesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information pertaining to a particular analysis within a study.
     * @summary GET an analysis
     * @param {string} id 
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesIdGet(id: string, nested?: boolean, options?: any) {
        return AnalysesApiFp(this.configuration).analysesIdGet(id, nested, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing analysis.
     * @summary PUT/update an analysis
     * @param {string} id 
     * @param {Analysis} [analysis] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesIdPut(id: string, analysis?: Analysis, options?: any) {
        return AnalysesApiFp(this.configuration).analysesIdPut(id, analysis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create an analysis
     * @summary POST/create an analysis
     * @param {Analysis} [analysis] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analysesPost(analysis?: Analysis, options?: any) {
        return AnalysesApiFp(this.configuration).analysesPost(analysis, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AnnotationsApi - axios parameter creator
 * @export
 */
export const AnnotationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get annotations for an available dataset
         * @summary Your GET endpoint
         * @param {string} [datasetId] see all annotations connected to this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsGet: async (datasetId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (datasetId !== undefined) {
                localVarQueryParameter['dataset_id'] = datasetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete annotation
         * @summary DELETE an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdDelete', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get an individual annotation
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [_export] return endpoint data in consumable/readable format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdGet: async (id: string, _export?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdGet', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_export !== undefined) {
                localVarQueryParameter['export'] = _export;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * edit an existing annotation
         * @summary Update an annotation
         * @param {string} id 
         * @param {Annotation} [annotation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdPut: async (id: string, annotation?: Annotation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('annotationsIdPut', 'id', id)
            const localVarPath = `/annotations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an annotation
         * @summary Post Annotation
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {Annotation} [annotation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsPost: async (source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', sourceId?: string, annotation?: Annotation, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationsApi - functional programming interface
 * @export
 */
export const AnnotationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnotationsApiAxiosParamCreator(configuration)
    return {
        /**
         * get annotations for an available dataset
         * @summary Your GET endpoint
         * @param {string} [datasetId] see all annotations connected to this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsGet(datasetId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsGet(datasetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete annotation
         * @summary DELETE an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get an individual annotation
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [_export] return endpoint data in consumable/readable format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdGet(id: string, _export?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationExport | Annotation & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdGet(id, _export, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * edit an existing annotation
         * @summary Update an annotation
         * @param {string} id 
         * @param {Annotation} [annotation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsIdPut(id: string, annotation?: Annotation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsIdPut(id, annotation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an annotation
         * @summary Post Annotation
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {Annotation} [annotation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annotationsPost(source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', sourceId?: string, annotation?: Annotation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annotationsPost(source, sourceId, annotation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnotationsApi - factory interface
 * @export
 */
export const AnnotationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnotationsApiFp(configuration)
    return {
        /**
         * get annotations for an available dataset
         * @summary Your GET endpoint
         * @param {string} [datasetId] see all annotations connected to this dataset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsGet(datasetId?: string, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.annotationsGet(datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete annotation
         * @summary DELETE an annotation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.annotationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get an individual annotation
         * @summary Your GET endpoint
         * @param {string} id 
         * @param {boolean} [_export] return endpoint data in consumable/readable format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdGet(id: string, _export?: boolean, options?: any): AxiosPromise<AnnotationExport | Annotation & ReadOnly> {
            return localVarFp.annotationsIdGet(id, _export, options).then((request) => request(axios, basePath));
        },
        /**
         * edit an existing annotation
         * @summary Update an annotation
         * @param {string} id 
         * @param {Annotation} [annotation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsIdPut(id: string, annotation?: Annotation, options?: any): AxiosPromise<Annotation> {
            return localVarFp.annotationsIdPut(id, annotation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an annotation
         * @summary Post Annotation
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {Annotation} [annotation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annotationsPost(source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', sourceId?: string, annotation?: Annotation, options?: any): AxiosPromise<Annotation & ReadOnly> {
            return localVarFp.annotationsPost(source, sourceId, annotation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationsApi - object-oriented interface
 * @export
 * @class AnnotationsApi
 * @extends {BaseAPI}
 */
export class AnnotationsApi extends BaseAPI {
    /**
     * get annotations for an available dataset
     * @summary Your GET endpoint
     * @param {string} [datasetId] see all annotations connected to this dataset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsGet(datasetId?: string, options?: any) {
        return AnnotationsApiFp(this.configuration).annotationsGet(datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete annotation
     * @summary DELETE an annotation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsIdDelete(id: string, options?: any) {
        return AnnotationsApiFp(this.configuration).annotationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get an individual annotation
     * @summary Your GET endpoint
     * @param {string} id 
     * @param {boolean} [_export] return endpoint data in consumable/readable format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsIdGet(id: string, _export?: boolean, options?: any) {
        return AnnotationsApiFp(this.configuration).annotationsIdGet(id, _export, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * edit an existing annotation
     * @summary Update an annotation
     * @param {string} id 
     * @param {Annotation} [annotation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsIdPut(id: string, annotation?: Annotation, options?: any) {
        return AnnotationsApiFp(this.configuration).annotationsIdPut(id, annotation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an annotation
     * @summary Post Annotation
     * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {Annotation} [annotation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public annotationsPost(source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', sourceId?: string, annotation?: Annotation, options?: any) {
        return AnnotationsApiFp(this.configuration).annotationsPost(source, sourceId, annotation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConditionsApi - axios parameter creator
 * @export
 */
export const ConditionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/conditions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a condition
         * @summary DELETE a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdDelete', 'id', id)
            const localVarPath = `/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdGet', 'id', id)
            const localVarPath = `/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id 
         * @param {Condition} [condition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdPut: async (id: string, condition?: Condition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('conditionsIdPut', 'id', id)
            const localVarPath = `/conditions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(condition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {Condition} [condition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsPost: async (condition?: Condition, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/conditions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(condition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConditionsApi - functional programming interface
 * @export
 */
export const ConditionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConditionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsGet(search, sort, page, desc, pageSize, name, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a condition
         * @summary DELETE a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Condition & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id 
         * @param {Condition} [condition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsIdPut(id: string, condition?: Condition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsIdPut(id, condition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {Condition} [condition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conditionsPost(condition?: Condition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Condition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conditionsPost(condition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConditionsApi - factory interface
 * @export
 */
export const ConditionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConditionsApiFp(configuration)
    return {
        /**
         * Get all conditions
         * @summary GET Conditions
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.conditionsGet(search, sort, page, desc, pageSize, name, description, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a condition
         * @summary DELETE a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.conditionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
         * @summary GET a condition
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdGet(id: string, options?: any): AxiosPromise<Condition & ReadOnly> {
            return localVarFp.conditionsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update a condition
         * @summary PUT/update a condition
         * @param {string} id 
         * @param {Condition} [condition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsIdPut(id: string, condition?: Condition, options?: any): AxiosPromise<void> {
            return localVarFp.conditionsIdPut(id, condition, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a condition
         * @summary POST/Create a condition
         * @param {Condition} [condition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conditionsPost(condition?: Condition, options?: any): AxiosPromise<Condition> {
            return localVarFp.conditionsPost(condition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConditionsApi - object-oriented interface
 * @export
 * @class ConditionsApi
 * @extends {BaseAPI}
 */
export class ConditionsApi extends BaseAPI {
    /**
     * Get all conditions
     * @summary GET Conditions
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, name?: string, description?: string, options?: any) {
        return ConditionsApiFp(this.configuration).conditionsGet(search, sort, page, desc, pageSize, name, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a condition
     * @summary DELETE a condition
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsIdDelete(id: string, options?: any) {
        return ConditionsApiFp(this.configuration).conditionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a condition (e.g., 2-back) that can be used in contrasts (e.g., 2-back - 1-back)
     * @summary GET a condition
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsIdGet(id: string, options?: any) {
        return ConditionsApiFp(this.configuration).conditionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a condition
     * @summary PUT/update a condition
     * @param {string} id 
     * @param {Condition} [condition] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsIdPut(id: string, condition?: Condition, options?: any) {
        return ConditionsApiFp(this.configuration).conditionsIdPut(id, condition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a condition
     * @summary POST/Create a condition
     * @param {Condition} [condition] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionsApi
     */
    public conditionsPost(condition?: Condition, options?: any) {
        return ConditionsApiFp(this.configuration).conditionsPost(condition, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatasetsApi - axios parameter creator
 * @export
 */
export const DatasetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of datasets.
         * @summary GET a list of datasets
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {boolean} [unique] whether to list clones with originals
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: boolean, source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', authors?: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/datasets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            if (unique !== undefined) {
                localVarQueryParameter['unique'] = unique;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (authors !== undefined) {
                localVarQueryParameter['authors'] = authors;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a dataset
         * @summary DELETE a Dataset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasetsIdDelete', 'id', id)
            const localVarPath = `/datasets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the information of a dataset with the matching dataset ID.
         * @summary GET a dataset
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsIdGet: async (id: string, nested?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasetsIdGet', 'id', id)
            const localVarPath = `/datasets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a dataset.
         * @summary PUT/update a dataset
         * @param {string} id 
         * @param {Dataset} [dataset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsIdPut: async (id: string, dataset?: Dataset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasetsIdPut', 'id', id)
            const localVarPath = `/datasets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a dataset.
         * @summary POST/create a dataset
         * @param {Dataset} [dataset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsPost: async (dataset?: Dataset, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/datasets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetsApi - functional programming interface
 * @export
 */
export const DatasetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of datasets.
         * @summary GET a list of datasets
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {boolean} [unique] whether to list clones with originals
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: boolean, source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', authors?: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a dataset
         * @summary DELETE a Dataset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the information of a dataset with the matching dataset ID.
         * @summary GET a dataset
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsIdGet(id: string, nested?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsIdGet(id, nested, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a dataset.
         * @summary PUT/update a dataset
         * @param {string} id 
         * @param {Dataset} [dataset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsIdPut(id: string, dataset?: Dataset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsIdPut(id, dataset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a dataset.
         * @summary POST/create a dataset
         * @param {Dataset} [dataset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasetsPost(dataset?: Dataset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasetsPost(dataset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatasetsApi - factory interface
 * @export
 */
export const DatasetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetsApiFp(configuration)
    return {
        /**
         * Get a list of datasets.
         * @summary GET a list of datasets
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {boolean} [unique] whether to list clones with originals
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: boolean, source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', authors?: string, userId?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.datasetsGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a dataset
         * @summary DELETE a Dataset
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.datasetsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the information of a dataset with the matching dataset ID.
         * @summary GET a dataset
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsIdGet(id: string, nested?: boolean, options?: any): AxiosPromise<Dataset & ReadOnly> {
            return localVarFp.datasetsIdGet(id, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a dataset.
         * @summary PUT/update a dataset
         * @param {string} id 
         * @param {Dataset} [dataset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsIdPut(id: string, dataset?: Dataset, options?: any): AxiosPromise<void> {
            return localVarFp.datasetsIdPut(id, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a dataset.
         * @summary POST/create a dataset
         * @param {Dataset} [dataset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasetsPost(dataset?: Dataset, options?: any): AxiosPromise<Dataset & ReadOnly> {
            return localVarFp.datasetsPost(dataset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetsApi - object-oriented interface
 * @export
 * @class DatasetsApi
 * @extends {BaseAPI}
 */
export class DatasetsApi extends BaseAPI {
    /**
     * Get a list of datasets.
     * @summary GET a list of datasets
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {boolean} [unique] whether to list clones with originals
     * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
     * @param {string} [authors] search authors
     * @param {string} [userId] user id you want to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: boolean, source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', authors?: string, userId?: string, options?: any) {
        return DatasetsApiFp(this.configuration).datasetsGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a dataset
     * @summary DELETE a Dataset
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsIdDelete(id: string, options?: any) {
        return DatasetsApiFp(this.configuration).datasetsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the information of a dataset with the matching dataset ID.
     * @summary GET a dataset
     * @param {string} id 
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsIdGet(id: string, nested?: boolean, options?: any) {
        return DatasetsApiFp(this.configuration).datasetsIdGet(id, nested, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a dataset.
     * @summary PUT/update a dataset
     * @param {string} id 
     * @param {Dataset} [dataset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsIdPut(id: string, dataset?: Dataset, options?: any) {
        return DatasetsApiFp(this.configuration).datasetsIdPut(id, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a dataset.
     * @summary POST/create a dataset
     * @param {Dataset} [dataset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetsApi
     */
    public datasetsPost(dataset?: Dataset, options?: any) {
        return DatasetsApiFp(this.configuration).datasetsPost(dataset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/images/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (analysisName !== undefined) {
                localVarQueryParameter['analysis_name'] = analysisName;
            }

            if (valueType !== undefined) {
                localVarQueryParameter['value_type'] = valueType;
            }

            if (space !== undefined) {
                localVarQueryParameter['space'] = space;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete an image
         * @summary DELETE an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdDelete', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdGet', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id 
         * @param {Image} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdPut: async (id: string, image?: Image, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdPut', 'id', id)
            const localVarPath = `/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(image, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {Image} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesPost: async (image?: Image, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/images/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(image, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete an image
         * @summary DELETE an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id 
         * @param {Image} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesIdPut(id: string, image?: Image, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdPut(id, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {Image} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagesPost(image?: Image, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesPost(image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * Retrieve and list images.
         * @summary GET a list of images
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {string} [filename] search filename field
         * @param {string} [analysisName] search analysis_name field
         * @param {string} [valueType] search value_type field
         * @param {string} [space] search space field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options).then((request) => request(axios, basePath));
        },
        /**
         * delete an image
         * @summary DELETE an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.imagesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about a particular image from an analysis.
         * @summary GET an image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdGet(id: string, options?: any): AxiosPromise<Image & ReadOnly> {
            return localVarFp.imagesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific image.
         * @summary PUT/update an image
         * @param {string} id 
         * @param {Image} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesIdPut(id: string, image?: Image, options?: any): AxiosPromise<void> {
            return localVarFp.imagesIdPut(id, image, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an image
         * @summary POST/create an image
         * @param {Image} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagesPost(image?: Image, options?: any): AxiosPromise<Image> {
            return localVarFp.imagesPost(image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * Retrieve and list images.
     * @summary GET a list of images
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {string} [filename] search filename field
     * @param {string} [analysisName] search analysis_name field
     * @param {string} [valueType] search value_type field
     * @param {string} [space] search space field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, filename?: string, analysisName?: string, valueType?: string, space?: string, options?: any) {
        return ImagesApiFp(this.configuration).imagesGet(search, sort, page, desc, pageSize, filename, analysisName, valueType, space, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete an image
     * @summary DELETE an image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesIdDelete(id: string, options?: any) {
        return ImagesApiFp(this.configuration).imagesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about a particular image from an analysis.
     * @summary GET an image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesIdGet(id: string, options?: any) {
        return ImagesApiFp(this.configuration).imagesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific image.
     * @summary PUT/update an image
     * @param {string} id 
     * @param {Image} [image] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesIdPut(id: string, image?: Image, options?: any) {
        return ImagesApiFp(this.configuration).imagesIdPut(id, image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an image
     * @summary POST/create an image
     * @param {Image} [image] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesPost(image?: Image, options?: any) {
        return ImagesApiFp(this.configuration).imagesPost(image, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PointsApi - axios parameter creator
 * @export
 */
export const PointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * list points in database
         * @summary Get Points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/points/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a point
         * @summary DELETE a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdDelete', 'id', id)
            const localVarPath = `/points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdGet', 'id', id)
            const localVarPath = `/points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id 
         * @param {Point} [point] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdPut: async (id: string, point?: Point, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointsIdPut', 'id', id)
            const localVarPath = `/points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(point, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add a point to an analysis
         * @summary POST Points
         * @param {Point} [point] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsPost: async (point?: Point, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/points/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(point, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PointsApi - functional programming interface
 * @export
 */
export const PointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PointsApiAxiosParamCreator(configuration)
    return {
        /**
         * list points in database
         * @summary Get Points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a point
         * @summary DELETE a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Point & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id 
         * @param {Point} [point] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsIdPut(id: string, point?: Point, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsIdPut(id, point, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * add a point to an analysis
         * @summary POST Points
         * @param {Point} [point] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointsPost(point?: Point, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Point>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointsPost(point, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PointsApi - factory interface
 * @export
 */
export const PointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PointsApiFp(configuration)
    return {
        /**
         * list points in database
         * @summary Get Points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsGet(options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.pointsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * delete a point
         * @summary DELETE a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.pointsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Information about a particular MRI coordinate
         * @summary GET a point
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdGet(id: string, options?: any): AxiosPromise<Point & ReadOnly> {
            return localVarFp.pointsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a particular MRI coordinate.
         * @summary PUT/update a point
         * @param {string} id 
         * @param {Point} [point] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsIdPut(id: string, point?: Point, options?: any): AxiosPromise<void> {
            return localVarFp.pointsIdPut(id, point, options).then((request) => request(axios, basePath));
        },
        /**
         * add a point to an analysis
         * @summary POST Points
         * @param {Point} [point] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointsPost(point?: Point, options?: any): AxiosPromise<Point> {
            return localVarFp.pointsPost(point, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PointsApi - object-oriented interface
 * @export
 * @class PointsApi
 * @extends {BaseAPI}
 */
export class PointsApi extends BaseAPI {
    /**
     * list points in database
     * @summary Get Points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsGet(options?: any) {
        return PointsApiFp(this.configuration).pointsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a point
     * @summary DELETE a point
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsIdDelete(id: string, options?: any) {
        return PointsApiFp(this.configuration).pointsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Information about a particular MRI coordinate
     * @summary GET a point
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsIdGet(id: string, options?: any) {
        return PointsApiFp(this.configuration).pointsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a particular MRI coordinate.
     * @summary PUT/update a point
     * @param {string} id 
     * @param {Point} [point] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsIdPut(id: string, point?: Point, options?: any) {
        return PointsApiFp(this.configuration).pointsIdPut(id, point, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add a point to an analysis
     * @summary POST Points
     * @param {Point} [point] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public pointsPost(point?: Point, options?: any) {
        return PointsApiFp(this.configuration).pointsPost(point, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudiesApi - axios parameter creator
 * @export
 */
export const StudiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {boolean} [unique] whether to list clones with originals
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {'coordinate' | 'image' | 'both'} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesGet: async (search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: boolean, source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', authors?: string, userId?: string, dataType?: 'coordinate' | 'image' | 'both', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            if (unique !== undefined) {
                localVarQueryParameter['unique'] = unique;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (authors !== undefined) {
                localVarQueryParameter['authors'] = authors;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['data_type'] = dataType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a study
         * @summary DELETE a study
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdDelete', 'id', id)
            const localVarPath = `/studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdGet: async (id: string, nested?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdGet', 'id', id)
            const localVarPath = `/studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nested !== undefined) {
                localVarQueryParameter['nested'] = nested;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id 
         * @param {Study} [study] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdPut: async (id: string, study?: Study, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studiesIdPut', 'id', id)
            const localVarPath = `/studies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(study, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {Study} [study] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesPost: async (source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', sourceId?: string, study?: Study, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/studies/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(study, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiesApi - functional programming interface
 * @export
 */
export const StudiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudiesApiAxiosParamCreator(configuration)
    return {
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {boolean} [unique] whether to list clones with originals
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {'coordinate' | 'image' | 'both'} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: boolean, source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', authors?: string, userId?: string, dataType?: 'coordinate' | 'image' | 'both', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, dataType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a study
         * @summary DELETE a study
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdGet(id: string, nested?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Study & ReadOnly>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdGet(id, nested, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id 
         * @param {Study} [study] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesIdPut(id: string, study?: Study, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesIdPut(id, study, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {Study} [study] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studiesPost(source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', sourceId?: string, study?: Study, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Study>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studiesPost(source, sourceId, study, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudiesApi - factory interface
 * @export
 */
export const StudiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudiesApiFp(configuration)
    return {
        /**
         * List studies
         * @summary GET a list of studies
         * @param {string} [search] search for entries that contain the substring
         * @param {string} [sort] Parameter to sort results on
         * @param {number} [page] page of results
         * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
         * @param {number} [pageSize] number of results to show on a page
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {string} [name] search the name field for a term
         * @param {string} [description] search description field for a term
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {boolean} [unique] whether to list clones with originals
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [authors] search authors
         * @param {string} [userId] user id you want to filter by
         * @param {'coordinate' | 'image' | 'both'} [dataType] whether searching for studies that contain coordinates, images, or both
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: boolean, source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', authors?: string, userId?: string, dataType?: 'coordinate' | 'image' | 'both', options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, dataType, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a study
         * @summary DELETE a study
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.studiesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a study.
         * @summary GET a study
         * @param {string} id 
         * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdGet(id: string, nested?: boolean, options?: any): AxiosPromise<Study & ReadOnly> {
            return localVarFp.studiesIdGet(id, nested, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a study.
         * @summary PUT/update a study
         * @param {string} id 
         * @param {Study} [study] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesIdPut(id: string, study?: Study, options?: any): AxiosPromise<void> {
            return localVarFp.studiesIdPut(id, study, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a study
         * @summary POST/create a study
         * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
         * @param {string} [sourceId] id of the resource you are either filtering/copying on
         * @param {Study} [study] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studiesPost(source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', sourceId?: string, study?: Study, options?: any): AxiosPromise<Study> {
            return localVarFp.studiesPost(source, sourceId, study, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudiesApi - object-oriented interface
 * @export
 * @class StudiesApi
 * @extends {BaseAPI}
 */
export class StudiesApi extends BaseAPI {
    /**
     * List studies
     * @summary GET a list of studies
     * @param {string} [search] search for entries that contain the substring
     * @param {string} [sort] Parameter to sort results on
     * @param {number} [page] page of results
     * @param {boolean} [desc] sort results by descending order (as opposed to ascending order)
     * @param {number} [pageSize] number of results to show on a page
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {string} [name] search the name field for a term
     * @param {string} [description] search description field for a term
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {boolean} [unique] whether to list clones with originals
     * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
     * @param {string} [authors] search authors
     * @param {string} [userId] user id you want to filter by
     * @param {'coordinate' | 'image' | 'both'} [dataType] whether searching for studies that contain coordinates, images, or both
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesGet(search?: string, sort?: string, page?: number, desc?: boolean, pageSize?: number, nested?: boolean, name?: string, description?: string, sourceId?: string, unique?: boolean, source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', authors?: string, userId?: string, dataType?: 'coordinate' | 'image' | 'both', options?: any) {
        return StudiesApiFp(this.configuration).studiesGet(search, sort, page, desc, pageSize, nested, name, description, sourceId, unique, source, authors, userId, dataType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a study
     * @summary DELETE a study
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesIdDelete(id: string, options?: any) {
        return StudiesApiFp(this.configuration).studiesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a study.
     * @summary GET a study
     * @param {string} id 
     * @param {boolean} [nested] whether to show the URI to a resource (false) or to embed the object in the response (true)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesIdGet(id: string, nested?: boolean, options?: any) {
        return StudiesApiFp(this.configuration).studiesIdGet(id, nested, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a study.
     * @summary PUT/update a study
     * @param {string} id 
     * @param {Study} [study] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesIdPut(id: string, study?: Study, options?: any) {
        return StudiesApiFp(this.configuration).studiesIdPut(id, study, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a study
     * @summary POST/create a study
     * @param {'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery'} [source] the source of the resource you would like to filter/copy from
     * @param {string} [sourceId] id of the resource you are either filtering/copying on
     * @param {Study} [study] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public studiesPost(source?: 'neurostore' | 'neurovault' | 'pubmed' | 'neurosynth' | 'neuroquery', sourceId?: string, study?: Study, options?: any) {
        return StudiesApiFp(this.configuration).studiesPost(source, sourceId, study, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get list of users
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Individual User Profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Individual Profile
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut: async (id: string, user?: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdPut', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (user?: User, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JSON-Web-Token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * get list of users
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Individual User Profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Individual Profile
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdPut(id: string, user?: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdPut(id, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create a user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(user?: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * get list of users
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.usersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Individual User Profile
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.usersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Individual Profile
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(id: string, user?: User, options?: any): AxiosPromise<User> {
            return localVarFp.usersIdPut(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * create a user
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user?: User, options?: any): AxiosPromise<User> {
            return localVarFp.usersPost(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * get list of users
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersGet(options?: any) {
        return UserApiFp(this.configuration).usersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Individual User Profile
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdGet(id: string, options?: any) {
        return UserApiFp(this.configuration).usersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Individual Profile
     * @param {string} id 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersIdPut(id: string, user?: User, options?: any) {
        return UserApiFp(this.configuration).usersIdPut(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a user
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public usersPost(user?: User, options?: any) {
        return UserApiFp(this.configuration).usersPost(user, options).then((request) => request(this.axios, this.basePath));
    }
}


